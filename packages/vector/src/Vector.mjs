// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Bvt from "./impl/Bvt.mjs";
import * as Curry from "@rescript/std/lib/es6/curry.js";
import * as Caml_option from "@rescript/std/lib/es6/caml_option.js";

function get(v, i) {
  if (i < 0 || i >= v.size) {
    return ;
  } else {
    return Caml_option.some(Bvt.getUnsafe(v, i));
  }
}

function getExn(v, i) {
  if (!(i >= 0 && i < v.size)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Vector.res",
            11,
            2
          ],
          Error: new Error()
        };
  }
  return Bvt.getUnsafe(v, i);
}

function getByU(vec, pred) {
  var i = 0;
  var r;
  while(r === undefined && i < vec.size) {
    var ar = Bvt.getArrayUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      var v = ar[j];
      if (pred(v)) {
        r = Caml_option.some(v);
      }
      
    }
    i = i + len | 0;
  };
  return r;
}

function getBy(vec, pred) {
  return getByU(vec, Curry.__1(pred));
}

function getIndexByU(vec, pred) {
  var i = 0;
  var r;
  while(r === undefined && i < vec.size) {
    var ar = Bvt.getArrayUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      var v = ar[j];
      if (pred(v)) {
        r = i;
      }
      i = i + 1 | 0;
    }
  };
  return r;
}

function getIndexBy(vec, pred) {
  return getIndexByU(vec, Curry.__1(pred));
}

function set(vec, i, x) {
  if (i < 0 || i >= vec.size) {
    return ;
  } else {
    return Bvt.setUnsafe(vec, i, x);
  }
}

function setExn(vec, i, x) {
  if (!(i >= 0 && i < vec.size)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Vector.res",
            61,
            2
          ],
          Error: new Error()
        };
  }
  return Bvt.setUnsafe(vec, i, x);
}

function reduceU(vec, init, f) {
  var i = 0;
  var acc = init;
  while(i < vec.size) {
    var ar = Bvt.getArrayUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      acc = f(acc, ar[j]);
    }
    i = i + len | 0;
  };
  return acc;
}

function reduce(vec, init, f) {
  return reduceU(vec, init, Curry.__2(f));
}

function reduceWithIndexU(vec, init, f) {
  var i = 0;
  var acc = init;
  while(i < vec.size) {
    var ar = Bvt.getArrayUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      acc = f(acc, ar[j], i);
      i = i + 1 | 0;
    }
  };
  return acc;
}

function reduceWithIndex(vec, init, f) {
  return reduceWithIndexU(vec, init, Curry.__3(f));
}

function mapU(vec, f) {
  return reduceU(vec, Bvt.make(undefined), (function (res, v) {
                return Bvt.push(res, f(v));
              }));
}

function map(vec, f) {
  return mapU(vec, Curry.__1(f));
}

function mapWithIndexU(vec, f) {
  return reduceWithIndexU(vec, Bvt.make(undefined), (function (res, v, i) {
                return Bvt.push(res, f(v, i));
              }));
}

function mapWithIndex(vec, f) {
  return mapWithIndexU(vec, Curry.__2(f));
}

function keepU(vec, f) {
  return reduceU(vec, Bvt.make(undefined), (function (res, v) {
                if (f(v)) {
                  return Bvt.push(res, v);
                } else {
                  return res;
                }
              }));
}

function keep(vec, f) {
  return keepU(vec, Curry.__1(f));
}

function keepMapU(vec, f) {
  return reduceU(vec, Bvt.make(undefined), (function (acc, v) {
                var v$1 = f(v);
                if (v$1 !== undefined) {
                  return Bvt.push(acc, Caml_option.valFromOption(v$1));
                } else {
                  return acc;
                }
              }));
}

function keepMap(vec, f) {
  return keepMapU(vec, Curry.__1(f));
}

function keepWithIndexU(vec, f) {
  return reduceWithIndexU(vec, Bvt.make(undefined), (function (res, v, i) {
                if (f(v, i)) {
                  return Bvt.push(res, v);
                } else {
                  return res;
                }
              }));
}

function keepWithIndex(vec, f) {
  return keepWithIndexU(vec, Curry.__2(f));
}

function forEachU(vec, f) {
  var i = 0;
  while(i < vec.size) {
    var ar = Bvt.getArrayUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      f(ar[j]);
    }
    i = i + len | 0;
  };
  
}

function forEach(vec, f) {
  return forEachU(vec, Curry.__1(f));
}

function forEachWithIndexU(vec, f) {
  var i = 0;
  while(i < vec.size) {
    var ar = Bvt.getArrayUnsafe(vec, i);
    var len = ar.length;
    for(var j = 0; j < len; ++j){
      f(ar[j], i);
      i = i + 1 | 0;
    }
  };
  
}

function forEachWithIndex(vec, f) {
  return forEachWithIndexU(vec, Curry.__2(f));
}

function someU(vec, f) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === Bvt.length(vec)) {
      return false;
    }
    if (f(Bvt.getUnsafe(vec, i))) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function some(vec, f) {
  return someU(vec, Curry.__1(f));
}

function everyU(vec, f) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i === Bvt.length(vec)) {
      return true;
    }
    if (!f(Bvt.getUnsafe(vec, i))) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function every(vec, f) {
  return everyU(vec, Curry.__1(f));
}

var make = Bvt.make;

var length = Bvt.length;

var push = Bvt.push;

var pop = Bvt.pop;

var getUnsafe = Bvt.getUnsafe;

var setUnsafe = Bvt.setUnsafe;

var fromArray = Bvt.fromArray;

var toArray = Bvt.toArray;

export {
  make ,
  length ,
  push ,
  pop ,
  get ,
  getExn ,
  getUnsafe ,
  getByU ,
  getBy ,
  getIndexByU ,
  getIndexBy ,
  set ,
  setExn ,
  setUnsafe ,
  reduceU ,
  reduce ,
  reduceWithIndexU ,
  reduceWithIndex ,
  mapU ,
  map ,
  mapWithIndexU ,
  mapWithIndex ,
  keepU ,
  keep ,
  keepMapU ,
  keepMap ,
  keepWithIndexU ,
  keepWithIndex ,
  forEachU ,
  forEach ,
  forEachWithIndexU ,
  forEachWithIndex ,
  someU ,
  some ,
  everyU ,
  every ,
  fromArray ,
  toArray ,
  
}
/* No side effect */
